import { filterOutUndefined } from "../../lib/object";

const BASE_URL = "https://gateway.chub.ai";
const API_URL = `${BASE_URL}/api`;

export type UUID = string & {
  readonly __type: "UUID";
};

export type ChubPage<T> = {
  readonly count: number;
  readonly nodes: readonly T[];
  readonly page: number;
  readonly previous_cursor: null | string;
  readonly cursor: null | string;
};

export type ChubUserId = number & {
  readonly __type: "ChubUserId";
};

export type ChubUsername = string & {
  readonly __type: "ChubUsername";
};

export type ChubSelfUser = {
  readonly id: ChubUserId;
  /** Autogenerated username */
  readonly name: ChubUsername;
  readonly user_name: string;
  readonly avatar_url: string;
  readonly subscription: number;
  readonly is_admin: boolean;
  readonly is_mod: boolean;
  readonly is_verified: boolean;
  readonly no_nsfw: boolean;
  readonly no_nsfl: boolean;
  readonly alpha_user: boolean;
  readonly trial_remaining: number;
  readonly verified_age: boolean;
};

// TODO: Define the `ChubModel` type properly when more information is available.
export type ChubModel = {};

export type ChubUser = {
  readonly id: ChubUserId;
  readonly avatarUrl: string;
  /** Username */
  readonly username: string;
  /** Persona name */
  readonly name: string;
  readonly first_name: string;
  readonly last_name: string;
  readonly public_email: string | null;
  readonly projects: ChubPage<ChubCardRaw>;
  readonly bio: string | null;
  readonly discord: string | null;
  readonly agnai_id: string | null;
  readonly avatar_url: string;
  readonly models: ChubPage<ChubModel>;
  readonly n_followees: number;
  readonly n_followers: number;
  /** Whether the user follows you */
  readonly user_follows: boolean;
  /** Whether you follow the user */
  readonly follows_user: boolean;
  readonly user_blocks: boolean;
  readonly badges: unknown[];
};

export type ChubCardId = number & {
  readonly __type: "ChubCardId";
};

export type ChubCardFullPath = string & {
  readonly __type: "ChubCardFullPath";
};

export interface ChubLabel {
  readonly title: string;
  readonly description: string;
}

export interface ChubCard {
  readonly id: ChubCardId;
  readonly name: string;
  readonly fullPath: ChubCardFullPath;
  readonly description: string;
  readonly starCount: number;
  readonly lastActivityAt: Date;
  readonly createdAt: Date;
  readonly labels: readonly ChubLabel[];
  readonly topics: readonly string[];
  readonly forksCount: number;
  readonly rating: number;
  readonly ratingCount: number;
  readonly projectSpace: "characters" | "lorebooks";
  /** -1 for anonymous */
  readonly creatorId: number;
  readonly nTokens: number;
  readonly tagline: string;
  readonly primaryFormat: "tavern";
  readonly related_characters: readonly number[];
  readonly related_lorebooks: readonly number[];
  readonly related_prompts: readonly number[];
  readonly related_extensions: readonly number[];
  readonly hasGallery: boolean;
  readonly nChats: number;
  readonly nMessages: number;
  readonly definition: null | string;
  readonly permissions: "read" | "write" | "admin";
  readonly is_public: boolean;
  readonly is_favorite: boolean;
  readonly nsfw_image: boolean;
  readonly n_public_chats: number;
  readonly n_favorites: number;
  readonly is_unlisted: boolean;
  readonly avatar_url: string;
  readonly max_res_url: string;
  readonly bound_preset: null | string;
  readonly project_uuid: null | string;
  readonly voice_id: null | string;
  readonly verified: boolean;
  readonly recommended: boolean;
  readonly ratings_disabled: boolean;
  readonly lang_id: number;
  readonly badges: readonly string[];
}

interface ChubCardRaw extends Omit<ChubCard, "lastActivityAt" | "createdAt"> {
  readonly lastActivityAt: string;
  readonly createdAt: string;
}

export function chubCardRawToChubCard(raw: ChubCardRaw): ChubCard {
  return {
    ...raw,
    lastActivityAt: new Date(raw.lastActivityAt),
    createdAt: new Date(raw.createdAt),
  };
}

export async function chubListSimilarCards(
  id: number
): Promise<readonly ChubCard[]> {
  const response = await fetch(`${API_URL}/projects/similar/${id}/true/true`);
  const data: ChubPage<ChubCardRaw> = await response.json();
  return data.nodes.map(chubCardRawToChubCard);
}

interface ChubGetCardResponse {
  readonly errors: readonly unknown[] | null;
  readonly node: ChubCardRaw;
  readonly nodes: Record<`${bigint}`, ChubCardRaw>;
  readonly permissions: "read";
  readonly is_favorite: boolean;
}

export function isProbablyChubCardFullPath(
  fullPath: unknown
): fullPath is ChubCardFullPath {
  return typeof fullPath === "string" && /^[^/]+[/][^/]+$/.test(fullPath);
}

export async function chubGetCardByFullPath(
  fullPath: ChubCardFullPath
): Promise<ChubCard> {
  const response = await fetch(`${API_URL}/characters/${fullPath}`);
  const data: ChubGetCardResponse = await response.json();
  return chubCardRawToChubCard(data.node);
}

export function isProbablyChubCardId(id: unknown): id is ChubCardId {
  return typeof id === "number" && Number.isInteger(id) && id > 0;
}

export async function chubGetCardById(id: ChubCardId): Promise<ChubCard> {
  const response = await fetch(`${API_URL}/characters/${id}`);
  const data: ChubGetCardResponse = await response.json();
  return chubCardRawToChubCard(data.node);
}

export async function chubGetCard(
  id: ChubCardId | ChubCardFullPath
): Promise<ChubCard> {
  if (isProbablyChubCardId(id)) {
    return await chubGetCardById(id);
  } else {
    return await chubGetCardByFullPath(id);
  }
}

export type ChubSearchParams = {
  first?: number;
  namespace?: "characters" | "lorebooks";
  nsfw?: boolean;
  nsfl?: boolean;
  chub?: boolean;
  count?: boolean;
  topics?: string;
  exclude_mine?: boolean;
  include_forks?: boolean;
  sort?:
    | "default"
    | "trending"
    | "ai_rating"
    | "star_count"
    | "msgs_chat"
    | "chats_user"
    | "msgs_user"
    | "random"
    | "rating"
    | "last_activity_at"
    | "name"
    | "n_tokens"
    | "n_favorites"
    | "created_at"
    | "public_chats"
    | "download_count";
  search?: string;
  username?: string;
  my_favorites?: boolean;
  min_tokens?: number;
  page?: number;
};

export const CHUB_SORT_NAMES = [
  "User Default",
  "Trending",
  "AI Rating",
  "Popularity",
  "Messages per Chat",
  "Chats per User",
  "Messages per User",
  "Random",
  "Rating",
  "Update Time",
  "Name",
  "# Tokens",
  "# Favorited",
  "Creation Time",
  "# Public Chats",
];
export type ChubSortName = (typeof CHUB_SORT_NAMES)[number];

export const CHUB_SORT_NAME_TO_TYPE = {
  "User Default": "default",
  Trending: "trending",
  "AI Rating": "ai_rating",
  Popularity: "star_count",
  "Messages per Chat": "msgs_chat",
  "Chats per User": "chats_user",
  "Messages per User": "msgs_user",
  Random: "random",
  Rating: "rating",
  "Update Time": "last_activity_at",
  Name: "name",
  "# Tokens": "n_tokens",
  "# Favorited": "n_favorites",
  "Creation Time": "created_at",
  "# Public Chats": "public_chats",
  "# Downloads": "download_count",
} satisfies Record<ChubSortName, ChubSearchParams["sort"]>;

export async function chubSearchCards(
  params: ChubSearchParams
): Promise<readonly ChubCard[]> {
  const query = new URLSearchParams(
    params as Record<string, string>
  ).toString();
  const response = await fetch(`${BASE_URL}/search?${query}`);
  const data: { readonly data: ChubPage<ChubCardRaw> } = await response.json();
  return data.data.nodes.map(chubCardRawToChubCard);
}

export type ChubTimelineParams = {
  readonly cursor?: string | undefined;
  readonly page?: number | undefined;
  readonly count?: boolean | undefined;
};

export async function chubGetTimelinePage(
  params: ChubTimelineParams = {}
): Promise<readonly ChubCard[]> {
  const query = new URLSearchParams(
    filterOutUndefined(params) as Record<string, string>
  ).toString();
  const response = await fetch(`${API_URL}/timeline/v1?${query}`);
  const { data }: { readonly data: ChubPage<ChubCardRaw> } =
    await response.json();
  const result = data.nodes.map(chubCardRawToChubCard);
  return result;
}

export async function chubGetSelfUser(): Promise<ChubSelfUser> {
  const response = await fetch(`${API_URL}/self`);
  return await response.json();
}

export async function chubGetUserById(username: string): Promise<ChubUser> {
  const response = await fetch(`${API_URL}/users/${username}`);
  return await response.json();
}

export type ChubCardQuery =
  | { type: "timeline"; cursor?: string }
  | { type: "search"; params: ChubSearchParams; cursor?: string };

export async function chubGetCardsByQuery(
  query: ChubCardQuery
): Promise<readonly ChubCard[]> {
  const widenedQuery = query;
  switch (query.type) {
    case "timeline":
      return await chubGetTimelinePage({ cursor: query.cursor });
    case "search":
      return await chubSearchCards(query.params);
    default:
      query satisfies never; // Ensure all cases are handled
      throw new Error(`Unsupported query type: ${widenedQuery.type}`);
  }
}

export type ChubFollow = {
  readonly user_id: ChubUserId;
  readonly avatar_url: string;
  readonly username: string;
};

export type ChubFollowsResponse = {
  readonly follows: readonly ChubFollow[];
  readonly tag_follows: readonly unknown[];
  readonly count: number;
  readonly tag_count: number;
  readonly page: number;
};

export type ChubGetFollowsParams = {
  readonly page?: number;
};

export async function chubGetFollowsByUsername(
  username: string,
  params: ChubGetFollowsParams = {}
): Promise<ChubFollowsResponse> {
  const query = new URLSearchParams({
    page: "1",
    ...params,
  } as Record<string, string>).toString();
  const response = await fetch(`${API_URL}/follows/${username}?${query}`);
  return await response.json();
}

export type ChubConfigEntry =
  | {
      readonly id: "theme";
      readonly sub_id: "Default";
      readonly value: {
        readonly mode?: "light" | "dark";
        readonly css_path?: string | null;
        readonly em_color?: string;
        readonly blur_nsfw?: boolean;
        readonly font_size?: string;
        readonly link_color?: string;
        readonly text_color?: string;
        readonly line_height?: string;
        readonly quote_color?: string;
        readonly use_sidebar?: boolean;
        readonly collapseable?: boolean;
        readonly card_font_size?: number;
        readonly show_background?: boolean;
        readonly show_custom_css?: boolean;
        readonly dark_header_color?: string;
        readonly quote_color_light?: string;
        readonly dark_submenu_color?: string;
        readonly light_header_color?: string;
        readonly light_submenu_color?: string;
        readonly chat_background_color?: string;
        readonly dark_background_color?: string;
        readonly light_background_color?: string;
        readonly message_background_color?: string;
        readonly chat_background_color_light?: string;
        readonly message_background_color_light?: string;
      };
    }
  | {
      readonly id: "use_legacy_ooba";
      readonly sub_id: "Default";
      readonly value: boolean;
    }
  | {
      readonly id: "open_ai_mode";
      readonly sub_id: "Default";
      readonly value: "api_key";
    }
  | {
      readonly id: "anthropic_mode";
      readonly sub_id: "Default";
      readonly value: "api_key";
    };

export type ChubConfigUpdateRequest = {
  readonly update: readonly ChubConfigEntry[];
};

export async function chubUpdateConfig(
  request: ChubConfigUpdateRequest
): Promise<void> {
  const response = await fetch(`${API_URL}/config`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(request),
  });
  return await response.json();
}

export type ChubConfigKey =
  | "theme"
  | "openAIKey"
  | "anthropicKey"
  | "openRouterKey"
  | "palm2Key"
  | "naiKey"
  | "characterOverrides"
  | "elevenLabsKey"
  | "reverseProxyKey"
  | "open_ai_reverse_proxy"
  | "open_ai_mode"
  | "anthropic_mode"
  | "anthropicReverseProxyKey"
  | "characterDraft"
  | "anthropic_reverse_proxy"
  | "use_legacy_ooba"
  | "api_url"
  | "ooba_streaming_url";

export type ChubConfigFetchRequest<Keys extends ChubConfigKey = ChubConfigKey> =
  {
    /** Value is typically `["*"]`. */
    readonly to_fetch: Record<Keys, string[]>;
  };

export type ChubConfigValue = ChubConfigEntry extends infer T
  ? T extends { value: infer Value }
    ? Value
    : never
  : never;

export type ChubConfigFetchResponse<
  Keys extends ChubConfigKey = ChubConfigKey
> = {
  readonly configs: {
    readonly [Key in Keys]: {
      readonly Default?: (ChubConfigEntry & { readonly id: Key })["value"];
    };
  };
};

export async function chubFetchConfig(
  request: ChubConfigFetchRequest
): Promise<ChubConfigFetchResponse> {
  const response = await fetch(`${BASE_URL}/config/fetch`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(request),
  });
  return await response.json();
}

export async function chubFetchEntireConfig(): Promise<ChubConfigFetchResponse> {
  return await chubFetchConfig({
    to_fetch: {
      theme: ["*"],
      anthropic_mode: ["*"],
      anthropicReverseProxyKey: ["*"],
      open_ai_mode: ["*"],
      open_ai_reverse_proxy: ["*"],
      anthropic_reverse_proxy: ["*"],
      use_legacy_ooba: ["*"],
      api_url: ["*"],
      ooba_streaming_url: ["*"],
      openAIKey: ["*"],
      anthropicKey: ["*"],
      openRouterKey: ["*"],
      palm2Key: ["*"],
      naiKey: ["*"],
      elevenLabsKey: ["*"],
      reverseProxyKey: ["*"],
      characterOverrides: ["*"],
      characterDraft: ["*"],
    },
  });
}

type ChubAccount = {
  readonly id: string;
  readonly name: string;
  readonly user_name: string;
  readonly avatar_url: string;
  readonly subscription: number;
  readonly is_admin: boolean;
  readonly is_mod: boolean;
  readonly is_verified: boolean;
  readonly no_nsfw: boolean;
  readonly no_nsfl: boolean;
  readonly alpha_user: boolean;
  readonly trial_remaining: number;
  readonly verified_age: boolean;
  readonly about_me: string;
  readonly profile: string;
  readonly invite_key: string | null;
  readonly blocked_tags: unknown[];
  readonly blocked_users: unknown[];
  readonly blacklisted_words: unknown[];
  readonly badges: unknown[];
  readonly default_sort: "n_favorites" | "n_tokens" | "last_activity_at";
  readonly tokens: unknown[];
  readonly cancelled: boolean;
  readonly paused: boolean;
  readonly failed: boolean;
  readonly stripe: null | unknown; // Stripe data
  readonly referrer_id: string | null;
  readonly email: string | null;
  readonly subscription_expires: null | string; // ISO date string or null
  readonly will_cancel: boolean;
  readonly last_payment_method: null | unknown; // Payment method data
  readonly fraud_flag: boolean;
  readonly config: ChubApiConfig;
  readonly balance: number;
  readonly bluesky: null | unknown; // Bluesky data
  readonly preferred_language: null | string; // ISO language code or null
};

export type ChubApiConfig = {
  // `string & {}` is a trick to allow any string but still allow for auto-completion.
  readonly api: "mercury" | "mars" | (string & {});
  readonly open_ai_mode: "api_key";
  readonly model: string;
  readonly open_ai_reverse_proxy: string;
  readonly jailbreak_prompt: string;
  readonly post_history_instructions: string;
  readonly impersonate_prompt: string;
  readonly api_url: string;
  readonly use_pygmalion_format: boolean;
  readonly generation_settings: Record<string, unknown>;
  readonly immersive_mode: boolean;
  readonly use_lorebooks: boolean;
  readonly text_streaming: boolean;
  readonly use_version_two: boolean;
  readonly anthropic_mode: "api_key";
  readonly anthropic_reverse_proxy: string;
  readonly auto_summarization: boolean;
  readonly use_legacy_ooba: boolean;
  readonly ooba_streaming_url: string;
  readonly input_sequence: string;
  readonly output_sequence: string;
  readonly stop_sequence: string;
  readonly wrap_sequences: boolean;
  readonly include_names: boolean;
  readonly chat_separator: string;
  readonly assistant_prefill: string;
  readonly prompt_note: {
    readonly note: string;
    readonly depth: number;
  };
  readonly tts_api: "elevenlabs";
  readonly tts_model: string;
  readonly tts_voice: string;
  readonly auto_tts: boolean;
  readonly chub_tts: boolean;
  readonly narrate_quotes: boolean;
  readonly narrate_inside: boolean;
  readonly narrate_delimiter: string;
  readonly similarity_boost: number;
  readonly stability: number;
  readonly use_speaker_boost: boolean;
  readonly pitch: number;
  readonly rate: number;
  readonly ban_emoticons: boolean;
  readonly nrep_penalty: number;
  readonly nfreq_penalty: number;
  readonly nai_preamble: string;
  readonly nai_prefix: "vanilla";
  readonly nai_phrase_rep_pen: "off";
  readonly prompt_template: null | string; // Template for prompts
  readonly message_template: null | string; // Template for messages
};

export async function chubGetAccount(): Promise<ChubAccount> {
  const response = await fetch(`${API_URL}/account`);
  return await response.json();
}

type ChubChatParams = {
  readonly nocache?: number | undefined;
  readonly include_messages?: boolean | undefined;
  readonly include_config?: boolean | undefined;
  readonly include_meta?: boolean | undefined;
};

type ChubChatId = number & {
  readonly __type: "ChubChatId";
};

type ChubChatMessageId = number & {
  readonly __type: "ChubChatMessageId";
};

type IsoDateString = string & {
  readonly __type: "IsoDateString";
};

type ChubChatMessage = {
  readonly id: ChubChatMessageId;
  // TODO: is this correct?
  readonly speaker_id: ChubCardId | ChubUserId;
  readonly message: string;
  readonly parent_id: null | ChubChatMessageId;
  readonly extensions: Record<string, unknown>;
  readonly chat_id: number; // ChubChatId
  readonly created_at: IsoDateString;
  readonly is_bot: boolean;
  readonly is_main: boolean;
  readonly child_ids: readonly ChubChatMessageId[];
  readonly color: string; // Hex color code
  readonly model_id: null | string; // Model identifier
  readonly originator: null | string; // Originator identifier
};

type ChubChatResponse = {
  readonly chat: null | unknown;
  readonly roots: readonly ChubChatMessageId[];
  readonly starts: readonly ChubChatMessageId[];
  readonly leaves: readonly ChubChatMessageId[];
  readonly chatMessages: Record<ChubChatMessageId, ChubChatMessage>;
  readonly config: null | unknown;
};

export async function chubGetChat(
  chatId: ChubChatId,
  params: ChubChatParams = {}
): Promise<ChubChatResponse> {
  const query = new URLSearchParams(
    filterOutUndefined({
      nocache: Math.random().toString(),
      ...params,
    }) as unknown as Record<string, string>
  ).toString();
  const response = await fetch(`${API_URL}/core/chats/v2/${chatId}?${query}`);
  return await response.json();
}

type ChubModelId = number & {
  readonly __type: "ChubModelId";
};

// TODO: test
type ChubChatMessageRequestCreate = {};
// TODO: test
type ChubChatMessageRequestDelete = {};
/** Optional fields are typically visible on a model message update. */
type ChubChatMessageRequestUpdate = {
  readonly id: ChubChatMessageId; // ID of the message to update
  readonly message: string; // New message content
  readonly color?: string; // Hex color code for the message
  readonly is_main?: boolean; // Whether to set this message as main
  readonly model_id?: ChubModelId; // Model identifier for the message
  readonly extensions?: Record<string, unknown>; // Optional extensions for the message
};

type ChubChatMessageRequest = {
  readonly create_ids: readonly ChubChatMessageRequestCreate[];
  readonly delete_ids: readonly ChubChatMessageRequestDelete[];
  readonly main_ids?: readonly ChubChatMessageId[]; // IDs to set as main messages
  readonly unmain_ids?: readonly ChubChatMessageId[]; // IDs to unset as main messages
  readonly update_ids?: readonly ChubChatMessageRequestUpdate[]; // Updates to existing messages
};

/** Optional fields are typically visible on a model message update. */
type ChubChatMessageResponseUpdate = {
  readonly short_id: UUID;
  readonly id: ChubChatMessageId;
  readonly message: string;
  readonly color?: string; // Hex color code
  readonly is_main: boolean;
  readonly model_id?: ChubModelId; // Model identifier
  readonly extensions?: Record<string, unknown>;
};

type ChubChatMessageResponseCreate = {
  readonly model: string; // Model identifier
  readonly message_uuid: null | UUID; // UUID for the message
  readonly api: "mercury" | "mars"; // API type
  readonly id: ChubChatMessageId;
  readonly is_bot: boolean;
  readonly extensions: Record<string, unknown>;
  readonly is_main: boolean;
  readonly message: string;
  readonly speaker_id: ChubCardId | ChubUserId; // Speaker identifier
  readonly parent_id: null | ChubChatMessageId; // Parent message ID
};

// TODO: test deleting a message
type ChubChatMessageResponseDelete = {};

type ChubChatAtomicMessageResponse = {
  readonly short_id: UUID;
  readonly create_ids: readonly ChubChatMessageResponseCreate[];
  readonly update_ids: readonly ChubChatMessageResponseUpdate[];
  readonly delete_ids: readonly ChubChatMessageResponseDelete[];
};

export async function chubPostAtomicMessage(
  chatId: ChubChatId,
  message: ChubChatMessageRequest
): Promise<ChubChatAtomicMessageResponse> {
  const response = await fetch(
    `${API_URL}/core/chats/v2/${chatId}/messages/atomic`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(message),
    }
  );
  return await response.json();
}

export type ChubPrompt = {
  readonly template: string;
  readonly frequency_penalty: number;
  readonly max_tokens: number;
  readonly min_tokens: number;
  readonly model: string;
  readonly n_tokens: number;
  readonly presence_penalty: number;
  readonly token_repetition_penalty: number;
  readonly stop: readonly string[];
  readonly stream: boolean;
  readonly temperature: number;
  readonly top_p: number;
  readonly top_k: number;
};

export async function chubSetPrompt(prompt: ChubPrompt): Promise<void> {
  await fetch(`${API_URL}/prompt`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(prompt),
  });
}
